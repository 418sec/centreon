#! /usr/bin/perl -w
###################################################################
# Oreon is developped with GPL Licence 2.0 
#
# GPL License: http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
#
# Developped by : Julien Mathis - Romain Le Merlus
#
###################################################################
# This program is free software; you can redistfribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
#    For information : contact@merethis.com
####################################################################
#
# Script init
#

use strict;
use warnings;
use DBI;
use threads;
use threads::shared;

use RRDs;

use File::Copy;

#my $installedPath = "@OREON_PATH@/ODS/";
my $installedPath = "/srv/oreon/ODS/";

my $LOG = $installedPath."var/ods.log";
my $PID = $installedPath."var/ods.pid";

# Init Globals
use vars qw($debug $LOG %status $generalcounter);
use vars qw($mysql_user $mysql_passwd $mysql_host $mysql_database_oreon $mysql_database_ods);
use vars qw($con_oreon $con_ods);

$debug = 0;

# Flag for stoping ods
my $stop : shared = 1;

# Ods Stats
my $lineRead : shared = 0;
my $valueRecorded : shared = 0;

# Init value
my ($file, $line, @line_tab, @data_service, $hostname, $service_desc, $metric_id, $configuration);

# Init status tab
%status = ('OK' => '0', 'WARNING' => '1', 'CRITICAL' => '2', 'UNKNOWN' => '3', 'PENDING' => '4');

# Include Configuration Data
require $installedPath."etc/conf.pm";

sub catch_zap {
	$stop = 0;
	writeLogFile("Receiving order to stop...\n");
}

sub writeLogFile($){
	open (LOG, ">> ".$LOG) || print "can't write $LOG: $!";
	print LOG time()." - ".$_[0];
	close LOG or warn $!;
}

# Starting ODS Engine
writeLogFile("Starting ODS engine...\n");
writeLogFile("PID : ".$$."\n");

# checking if pid file exists.
if (-x $PID){
	writeLogFile("ods already runnig. can't launch again....\n");
	exit(2);
}

# Writing PID
open (PID, ">> ".$PID) || print "can't write PID : $!";
print PID $$ ;
close PID or warn $!;

# Set signals
$SIG{INT}  = \&catch_zap;

require $installedPath."lib/misc.pm";
require $installedPath."lib/purge.pm";
require $installedPath."lib/getHostData.pm";
require $installedPath."lib/getServiceData.pm";
require $installedPath."lib/indentifyService.pm";
require $installedPath."lib/verifyHostServiceIdName.pm";
require $installedPath."lib/identifyMetric.pm";
require $installedPath."lib/updateFunctions.pm";

sub CheckMySQLConnexion(){
	my $flag = 0;
	while ((!defined($con_oreon) || !$con_oreon->ping) && (!defined($con_ods) || !$con_ods->ping)){
		if (!defined($con_oreon)) {
			$con_oreon = DBI->connect("DBI:mysql:database=".$mysql_database_oreon.";host=".$mysql_host, $mysql_user, $mysql_passwd, {'RaiseError' => 0, 'PrintError' => 0, 'AutoCommit' => 1});
			if (!defined($con_oreon)) {
				writeLogFile("Error when connecting to database : " . $DBI::errstr . "\n");
				sleep(2);
			}
		} else {
			sleep(2);
			undef($con_oreon);
			$con_oreon = DBI->connect("DBI:mysql:database=".$mysql_database_oreon.";host=".$mysql_host, $mysql_user, $mysql_passwd, {'RaiseError' => 0, 'PrintError' => 0, 'AutoCommit' => 1});			
			if (defined($con_oreon)) {
				$flag = 1;
				writeLogFile("DataBase became UP !\n");
			}	
		}
		if (!defined($con_ods)) {
			$con_ods = DBI->connect("DBI:mysql:database=".$mysql_database_ods.";host=".$mysql_host, $mysql_user, $mysql_passwd, {'RaiseError' => 0, 'PrintError' => 0, 'AutoCommit' => 1});
			if (!defined($con_ods)) {
				writeLogFile("Error when connecting to database : " . $DBI::errstr . "\n");
				sleep(2);
			}
		} else {
			sleep(2);
			undef($con_ods);
			$con_ods = DBI->connect("DBI:mysql:database=".$mysql_database_ods.";host=".$mysql_host, $mysql_user, $mysql_passwd, {'RaiseError' => 0, 'PrintError' => 0, 'AutoCommit' => 1});
			if (defined($con_ods) && !$flag) {
				writeLogFile("DataBase became UP !\n");
			}	
		}
	}
	undef($flag);
}

sub CheckMySQLConnexionForODS(){
	while (!defined($con_ods) || !$con_ods->ping){
		if (!defined($con_ods)) {
			$con_ods = DBI->connect("DBI:mysql:database=".$mysql_database_ods.";host=".$mysql_host, $mysql_user, $mysql_passwd, {'RaiseError' => 0, 'PrintError' => 0, 'AutoCommit' => 1});
		} else {
			sleep(2);
			undef($con_ods);
			$con_ods = DBI->connect("DBI:mysql:database=".$mysql_database_ods.";host=".$mysql_host, $mysql_user, $mysql_passwd, {'RaiseError' => 0, 'PrintError' => 0, 'AutoCommit' => 1});
		}
	}
}

sub CheckMySQLConnexionForOreon(){
	while (!defined($con_oreon) || !$con_oreon->ping){
		if (!defined($con_oreon)) {
			$con_oreon = DBI->connect("DBI:mysql:database=".$mysql_database_oreon.";host=".$mysql_host, $mysql_user, $mysql_passwd, {'RaiseError' => 0, 'PrintError' => 0, 'AutoCommit' => 1});
		} else {
			sleep(2);
			undef($con_oreon);
			$con_oreon = DBI->connect("DBI:mysql:database=".$mysql_database_oreon.";host=".$mysql_host, $mysql_user, $mysql_passwd, {'RaiseError' => 0, 'PrintError' => 0, 'AutoCommit' => 1});			
		}
	}
}

########################################
# return perfdata file path
########################################

sub getPerfDataFile(){
	my ($filename, $sth2, $data, $con_ods);
	$con_ods = DBI->connect("DBI:mysql:database=".$mysql_database_ods.";host=".$mysql_host, $mysql_user, $mysql_passwd, {'RaiseError' => 0, 'PrintError' => 0, 'AutoCommit' => 1});
	$sth2 = $con_ods->prepare("SELECT perfdata_file FROM config");
	writeLogFile("Error when getting perfdata file : " . $sth2->errstr . "\n") if (!$sth2->execute);
	$data = $sth2->fetchrow_hashref();
	undef($sth2);
	$filename = $data->{'perfdata_file'};
	undef($data);
	undef($con_ods);
	return $filename;
}

########################################
# Move perfdata file to tmp file 
########################################

sub movePerfDataFile($){
	if (copy($_[0], $_[0]."_read")){
		writeLogFile("Error When removing service-perfdata file : $!") if (!unlink($_[0]));
		return(1);
	} else {
		writeLogFile("Error When moving data in tmp read file : $!");
		return(0);
	}
}

########################################
# Get ODS config data  
########################################

sub getConfig(){
	my ($sth2, $data, $con_ods);
	$con_ods = DBI->connect("DBI:mysql:database=".$mysql_database_ods.";host=".$mysql_host, $mysql_user, $mysql_passwd, {'RaiseError' => 0, 'PrintError' => 0, 'AutoCommit' => 1});
	$sth2 = $con_ods->prepare("SELECT auto_drop,drop_file,perfdata_file FROM config");
	writeLogFile("Error when getting drop and perfdata properties : ".$sth2->errstr."\n") if (!$sth2->execute);
	$data = $sth2->fetchrow_hashref();	
	undef($sth2);
	undef($con_ods);
	return($data);
}

sub GetPerfData(){
	# Init Var
	my ($line_tab, $sth2, $data, $flag_drop, $sleeptime);
	use vars qw($con_oreon $con_ods);
	CheckMySQLConnexion();				
	my $PFDT = getPerfDataFile();
	while ($stop) {
		if (-r $PFDT || -r $PFDT.".bckp"){
			# Move perfdata File befor reading		

			# Penser a lire le fichier de backup !

			if (movePerfDataFile($PFDT) && open(PFDT, "< $PFDT"."_read")){
				$data = getConfig();
				$PFDT = $data->{'perfdata_file'};
				$flag_drop = 1;
				if ($data->{'auto_drop'} == 1 && defined($data->{'drop_file'})){
					if (!open(DROP, ">> ".$data->{'drop_file'})){
						$flag_drop = 0;
						writeLogFile("can't write in ".$data->{'drop_file'}." : $!");
					}
				} else {
					$flag_drop = 0;
				}
				undef($data);
				while (<PFDT>){
					$lineRead++;
					if (!$stop){
						writeLogFile("can't write in ".$installedPath."var/service-perfdata.bckp : $!") if (!open(BCKP, ">> ".$installedPath."/var/service-perfdata.bckp"));
						while (<PFDT>){
							print BCKP $_;
						}
						return;
					}
					print DROP $_  if ($flag_drop == 1);
			    	@line_tab = split('\t');
			    	$line_tab[2] =~ s/\\/\#BS\#/g;
			    	$line_tab[2] =~ s/\//\#S\#/g;
			    	if (defined($line_tab[5]) && ($line_tab[5] ne '' && $line_tab[5] ne "\n")){
						CheckMySQLConnexion();
						checkAndUpdate(@line_tab);
					}
					undef($line_tab);
				}
				close(PFDT);
				# Remove Read File
				writeLogFile("Error When removing service-perfdata file : $!") if (!unlink($PFDT."_read"));
				# Drop Data
				close(DROP) if ($flag_drop == 1);
				undef($line_tab);
				undef($flag_drop);
			} else {
				writeLogFile("Error When reading data in tmp read file : $!");
			}
		}
		my $i,
		$sleeptime = getSleepTime();
		for ($i = 0; $i <= $sleeptime && $stop; $i++){
			sleep(1);	
		}
		undef($sleeptime);
		undef($i);
	}
} 

########################################
# Check if nagios restart and if we 
# must to check configuration and 
# launch purge process  
# -> Thread
########################################

sub CheckRestart(){
	my ($last_restart_stt, $last_restart, $sth2, $data, $y);
	use vars qw($con_oreon $con_ods);
	
	CheckMySQLConnexion();
	$y = 1;
	while($stop){
		CheckMySQLConnexion();
		$last_restart = getLastRestart();
    	$last_restart_stt = getLastRestartInMemory();
		if (!$last_restart_stt || $last_restart ne $last_restart_stt){
			check_HostServiceID();
			if (getPurgeConfig()){
				CheckMySQLDrain();
				DeleteOldRrdDB();
			}
			saveLastRestartInMemory($last_restart);
		}
		$y++;
		sleep(5);
	}
}

########################################
# Purge MySQL data
########################################

sub purgeMysqlData($){
	my $sth2 = $_[0]->prepare("SELECT * FROM config");	
	writeLogFile("Error when getting len_storage_mysql properties : ".$sth2->errstr."\n")if (!$sth2->execute);
	my $data = $sth2->fetchrow_hashref();
	if (defined($data->{'len_storage_mysql'}) && $data->{'len_storage_mysql'} ne 0){
		my $delete_limit = time() - 60 * 60 * 24 * $data->{'len_storage_mysql'};
		$sth2 = $_[0]->prepare("DELETE FROM data_bin WHERE ctime < '".$delete_limit."'");
		writeLogFile("Error when purging Mysql data  : ".$sth2->errstr."\n")if (!$sth2->execute);
	}
	undef($sth2);
}

sub checkAndUpdate($){
	my $data_service;
	if ($_[5]){
		if ($_[1] =~ /[a-zA-Z]*_Module/){
			@data_service = identify_hidden_service($_[1], $_[2]); # return index_id and storage
			$valueRecorded = identify_hidden_metric($_[5], $data_service[0], $_[4], $_[0], $data_service[1], $valueRecorded, $data_service[2]) if (!$data_service[3]); # perfdata index status time type counter rebuild
		} else {
			@data_service = identify_service($_[1], $_[2]); # return index_id and storage
			$valueRecorded = identify_metric($_[5], $data_service[0], $_[4], $_[0], $data_service[1], $valueRecorded, $data_service[2]) if (!$data_service[3]); # perfdata index status time type counter rebuild
		}
	}
	undef(@data_service);
}


sub CheckNagiosStats(){
	while ($stop){
		sleep(1);
	}
}

sub CheckRebuild(){
	use vars qw($con_oreon $con_ods);
	my ($RRDdatabase_path, $len_storage_rrd, $y, $svc_mst_be_rbld);
	$y = 0;
	while ($stop){
		CheckMySQLConnexion();
		if ($y % 60 eq 0){
			my ($sth2, $svc_mst_be_rbld, $data, $ERR, $flag, $metric, $cpt);
			# ---------------------------------------------
			# Rebuild database
			$RRDdatabase_path = getRRDdatabase_path();
			$len_storage_rrd = getLenStorageDB();
			$len_storage_rrd = $len_storage_rrd * 60 * 60 * 24;
			# Check if backup directory is created
			system("mkdir $RRDdatabase_path/backup/") if (! -d "$RRDdatabase_path/backup/");
			
			$sth2 = $con_ods->prepare("SELECT id, service_id, host_name, service_description FROM index_data WHERE `must_be_rebuild` = '1'");
			writeLogFile("Error when getting service id who must be rebuild : ".$sth2->errstr."\n") if (!$sth2->execute);
			while ($svc_mst_be_rbld = $sth2->fetchrow_hashref()){
			
				my $sth = $con_ods->prepare("UPDATE index_data SET `must_be_rebuild` = '2' WHERE id = '".$svc_mst_be_rbld->{'id'}."'");
				writeLogFile("Error when getting perfdata file : " . $sth->errstr . "\n") if (!$sth->execute);
				undef($sth);
				
				writeLogFile("Rebuild Graphs for Services : ".$svc_mst_be_rbld->{'id'}."\n");
				
				# -----------------------------------------------------
				# Get check interval for this service
				my $interval;
				my $sth_interval;
				if ($svc_mst_be_rbld->{'host_name'} =~ /([a-zA-Z0-9]*)_Module/){
					if ($1 eq "Meta"){
						$svc_mst_be_rbld->{'service_description'} =~ /meta_([0-9]*)/; 
						$sth_interval = $con_oreon->prepare("SELECT normal_check_interval FROM meta_service WHERE meta_id = '".$1."'");
						if (!$sth_interval->execute) {writeLogFile("Error when getting metrics interval for Meta : " . $sth_interval->errstr . "\n");}
						my $meta_conf = $sth_interval->fetchrow_hashref();
						if (defined($meta_conf->{'normal_check_interval'}) && $meta_conf->{'normal_check_interval'}){
							$interval = $meta_conf->{'normal_check_interval'};
						} else {
							$interval = 2 * 60 + 30;
						}
						undef($meta_conf);
						undef($sth_interval);
					} elsif ($1 eq "OSL") {
						$svc_mst_be_rbld->{'service_description'} =~ /osl_([0-9]*)/; 
						$sth_interval = $con_oreon->prepare("SELECT normal_check_interval FROM osl WHERE osl_id = '".$1."'");
						if (!$sth_interval->execute) {writeLogFile("Error when getting metrics interval for osl : " . $sth_interval->errstr . "\n");}
						my $osl_conf = $sth_interval->fetchrow_hashref();
						if (defined($osl_conf->{'normal_check_interval'}) && $osl_conf->{'normal_check_interval'}){
							$interval = $osl_conf->{'normal_check_interval'};
						} else {
							$interval = 1 * 60 + 30;
						}
						undef($osl_conf);
						undef($sth_interval);
					} else {
						$interval = 90;
					}
				} else {
					my $best_mode = 0;
					if ($best_mode == 1){
						$interval = getServiceCheckIntervalFromService($svc_mst_be_rbld->{'id'}) * 60 + 30;
					} else {
						$interval = getServiceCheckIntervalFromService($svc_mst_be_rbld->{'id'}) * 60 * 2;
					}
				}		
				my $sth3 = $con_ods->prepare("SELECT metric_id, metric_name FROM metrics WHERE index_id = '".$svc_mst_be_rbld->{'id'}."'");
				if (!$sth3->execute) {writeLogFile("Error when getting metrics id who must be rebuild : " . $sth3->errstr . "\n");}
				while ($metric = $sth3->fetchrow_hashref()){
					writeLogFile("Get Data for rebuilding $RRDdatabase_path".$metric->{'metric_id'}.".rrd\n");					
					my $sth4 = $con_ods->prepare("SELECT * FROM data_bin WHERE id_metric = '".$metric->{'metric_id'}."' ORDER BY ctime");
					writeLogFile("Error when getting perfdata file : " . $sth4->errstr . "\n") if (!$sth4->execute);
					
					for ($flag = 0, $cpt = 0;$data = $sth4->fetchrow_hashref();$cpt++){
						if (!$flag){
							$interval = 330 if (!defined($interval));
							my $my_len_storage_rrd = $len_storage_rrd / $interval;
							writeLogFile("Rebuild database : ".$RRDdatabase_path.$metric->{'metric_id'}.".rrd (interval : $interval - Len : $my_len_storage_rrd)\n");				
							# backup old database
							system("mv ".$RRDdatabase_path.$metric->{'metric_id'}.".rrd $RRDdatabase_path/backup/".$metric->{'metric_id'}.".rrd");
							# Calculate first entry in database					
							my $begin = $data->{'ctime'} - 200;
							# Create RRD database
							RRDs::create($RRDdatabase_path.$metric->{'metric_id'}.".rrd", "-b ".$begin, "-s ".$interval, "DS:".substr($metric->{'metric_name'}, 0, 19).":GAUGE:".$interval.":U:U", "RRA:AVERAGE:0.5:1:".$my_len_storage_rrd, "RRA:MIN:0.5:12:".$my_len_storage_rrd, "RRA:MAX:0.5:12:".$my_len_storage_rrd);
							writeLogFile(substr($metric->{'metric_name'}, 0, 19)."\n");
							undef($my_len_storage_rrd);
							$ERR = RRDs::error;
							if ($ERR){writeLogFile("ERROR while creating ".$RRDdatabase_path.$metric->{'metric_id'}.".rrd : $ERR\n");}
							undef($ERR);
							undef($begin);
							undef($my_len_storage_rrd);
							$flag++;
						}
					
						# Update Database 
						RRDs::update ($RRDdatabase_path.$metric->{'metric_id'}.".rrd" , "--template", substr($metric->{'metric_name'}, 0, 19), $data->{'ctime'}.":".$data->{'value'});
						$ERR = RRDs::error;
					
						if ($ERR){writeLogFile("ERROR while updating ".$RRDdatabase_path.$metric->{'metric_id'}.".rrd at ".$data->{'ctime'}." -> ".$data->{'value'}." : $ERR\n");}
						undef($ERR);
					}
					writeLogFile("$cpt value insert\n");
					undef($sth4);
					# -----------------------------------------------------
				}
				undef($interval);
				undef($sth3);
				$sth = $con_ods->prepare("UPDATE index_data SET `must_be_rebuild` = '0' WHERE id = '".$svc_mst_be_rbld->{'id'}."'");
				writeLogFile("Error when getting perfdata file : " . $sth->errstr . "\n") if (!$sth->execute);
				undef($sth);
				undef($cpt);
				undef($ERR);
				undef($metric);
			}
			undef($flag);
			undef($svc_mst_be_rbld);
			undef($sth2);
			undef($data);
		}
		$y++;
		sleep(1);
	}
}

sub BuildReport(){
	while (1){
		;
	}
}

sub ParseLogSNMPTT(){
	while (1){
		sleep(10);
	}
}

# launch all threads

my $threadPerfdata 			= 	threads->new("GetPerfData");
my $threadCheckRestart		= 	threads->new("CheckRestart");
my $threadCheckRebuild		= 	threads->new("CheckRebuild");
my $threadBuildReport		= 	threads->new("BuildReports");
my $ParseLogSNMPTT			= 	threads->new("ParseLogSNMPTT");


#my $threadCheckNagiosStats	= 	threads->new("CheckNagiosStats");

# here make statistics
my ($lineReadpermin, $valueRecordedpermin, $lastlineRead, $lastvalueRecorded);
$lastlineRead = 0;
$lastvalueRecorded = 0;

my $y = 0;
while ($stop){
	if ($y % 60 eq 0){
		CheckMySQLConnexion();
		# ---------------------------------------------
		# Statistics For ODS
		if ($lastlineRead){
			$lineReadpermin = $lineRead - $lastlineRead;
		} else {
			$lineReadpermin = $lineRead;
		}
		$lastlineRead = $lineRead;
		if ($lastvalueRecorded){
			$valueRecordedpermin = $valueRecorded - $lastvalueRecorded;
		} else {
			$valueRecordedpermin = $valueRecorded;
		}
		$lastvalueRecorded = $valueRecorded;
		# ---------------------------------------------
		# Update statistics for ODS
		my $sth2 = $con_ods->prepare("UPDATE statistics SET `lineRead` = '$lineReadpermin', `valueReccorded` = '$valueRecordedpermin' LIMIT 1");
		writeLogFile("Error when getting drop and perfdata properties : ".$sth2->errstr."\n")if (!$sth2->execute);
		undef($sth2);
		# ---------------------------------------------
		# Purge MySQL data for not having a too big database.
		purgeMysqlData($con_ods);	
		# ---------------------------------------------
	}
	$y++;
	sleep(1);
}

# Waiting All threads

$threadPerfdata->join;
$threadCheckRestart->join;
$threadCheckRebuild->join;
#$threadCheckNagiosStats->join;

# Write in log file 
writeLogFile("Stopping ODS engine...\n");

# Delete PID File
writeLogFile("Error When removing pid file : $!") if (!unlink($PID));

exit(1);