#! /usr/bin/perl -w
###################################################################
# Centreon is developped with GPL Licence 2.0 
#
# GPL License: http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
#
# Developped by : Julien Mathis - Romain Le Merlus
#
###################################################################
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
#    For information : contact@merethis.com
####################################################################
#
# Script init
#

use strict;
use POSIX qw(mkfifo);
use DBI;

use IO::Select;
use IO::File;

use vars qw($debug $LOG %status $generalcounter $stop $method);
use vars qw($mysql_user $mysql_passwd $mysql_host $mysql_database_oreon $mysql_database_ods);
use vars qw($con);

$method = "system";

$debug = 0;
my $installedPath = "/srv/oreon/";
$LOG = $installedPath."var/centcore.log";
my $PID = $installedPath."var/centcore.pid";
my $FIFO = $installedPath."var/centcore";
$stop = 1;

# Include Configuration Data
require $installedPath."etc/conf.pm";

sub catch_zap {
	$stop = 0;
	writeLogFile("Receiving order to stop...\n");
}

sub writeLogFile($){
	open (LOG, ">> ".$LOG) || print "can't write $LOG: $!";
	print LOG time()." - ".$_[0];
	close LOG or warn $!;
}

my $timeBetween2SyncPerf = 60;

# Starting ODS Engine
writeLogFile("Starting ODS engine...\n");
writeLogFile("PID : ".$$."\n");

# checking if pid file exists.
if (-x $PID){
	writeLogFile("centcore already running. can't launch again....\n");
	exit(2);
}

# Writing PID
open (PID, ">> ".$PID) || print "can't write PID : $!";
print PID $$ ;
close PID or warn $!;

# Set signals
$SIG{INT}  		= \&catch_zap;
$SIG{'CHLD'} 	= 'IGNORE' ;

sub parseRequest($);
sub GetAllNagiosServerPerfData();

my $readset   = new IO::Select();

unlink $FIFO if (-p $FIFO);

unless (-p $FIFO) {
    unlink $FIFO;
    require POSIX;
    POSIX::mkfifo($FIFO, 0755) or die "can't mkfifo $FIFO: $!";
}

if (!(-p $FIFO && -w _ && -r _)){
	print $LOG "FIFO not open ! centcore stopped\n";
	exit(1);
}

my $fifoHandle = new IO::File($FIFO, O_RDWR|O_NONBLOCK, "0775");

# Add the handles for our programs into the readset.
# In other words, we're keeping track of these handles.

my $timeSyncPerf = 0;
while ($stop) {
	$readset->add($fifoHandle);
	# Select Wait
	while(my @ready = $readset->can_read(60)){
		# We have received a commande 
		foreach my $handle (@ready) {
    		my $str = Read($handle);
	    	# Let's go to parse KeyWords
	    	print "Parse Request ! \n";
	    	parseRequest($str);
	    }
	
	}
	writeLogFile("Receiving order to stop...\n") if (!$stop);
	my $flag = 1;
	my $difTime = time() - $timeSyncPerf if (defined($timeSyncPerf) && $timeSyncPerf);
	if ($flag && ((defined($difTime) && $timeBetween2SyncPerf <= $difTime) || $timeSyncPerf == 0)){
		print "$timeBetween2SyncPerf <= $difTime\n" if (defined($timeSyncPerf) && $timeSyncPerf);
		print "Synchronize Perf \n";
		# Get PerfData on Nagios Poller
		GetAllNagiosServerPerfData();
		$timeSyncPerf = time();
	}
	print "############################################\n";
	print "Timed out.\n";
}
$fifoHandle->close();

sub Read {
    my ($handle, $bytesToRead ) = @_;
    $bytesToRead = 1 unless $bytesToRead;

    my $message = '';
    my $readByte;

    while(1) {
        my $bytesRead = sysread( $handle, $readByte, $bytesToRead ) or last;
        $message .= $readByte if $bytesRead;
    }
    chomp $message if $message;
    return $message;
}

sub GetAllNagiosServerPerfData(){
	CheckMySQLConnexion();
	my $sth2 = $con->prepare("SELECT id FROM `nagios_server` WHERE `localhost` = '0'");
	writeLogFile("Error when getting server properties : ".$sth2->errstr."\n") if (!$sth2->execute());
	while (my $data = $sth2->fetchrow_hashref()){
		print 'NG : '.$data->{'id'}."\n";
		GetPerfData($data->{'id'});
		GetLogFile($data->{'id'});
	}
	$sth2->finish();
	$con->disconnect();
	return;
}

# -------------------
#      Functions 
# -------------------

# Functions

sub getNagiosConfigurationField($$){
	CheckMySQLConnexion();
	my $sth2 = $con->prepare("SELECT ".$_[1]." FROM `cfg_nagios` WHERE `nagios_server_id` = '".$_[0]."'");
	writeLogFile("Error when getting server properties : ".$sth2->errstr."\n") if (!$sth2->execute());
	my $data = $sth2->fetchrow_hashref();
	return $data->{$_[1]};
}

sub getLocalOptionsField($){
	CheckMySQLConnexion();
	my $sth2 = $con->prepare("SELECT ".$_[0]." FROM `general_opt` LIMIT 1");
	writeLogFile("Error when getting general options properties : ".$sth2->errstr."\n") if (!$sth2->execute());
	my $data = $sth2->fetchrow_hashref();
	return $data->{$_[0]};
}

sub getServerConfig($){
	CheckMySQLConnexion();
	my $sth2 = $con->prepare("SELECT * FROM `nagios_server` WHERE `id` = '".$_[0]."'");
	writeLogFile("Error when getting server properties : ".$sth2->errstr."\n") if (!$sth2->execute());
	return $sth2->fetchrow_hashref();
}

sub CheckMySQLConnexion(){
	my $flag = 0;
	while (!defined($con) || !$con->ping){
		if (!defined($con)) {
			$con = DBI->connect("DBI:mysql:database=".$mysql_database_oreon.";host=".$mysql_host, $mysql_user, $mysql_passwd, {'RaiseError' => 0, 'PrintError' => 0, 'AutoCommit' => 1});
			if (!defined($con)) {
				writeLogFile("Error when connecting to database : ".$DBI::errstr."\n");
				sleep(2);
			}
		} else {
			sleep(2);
			undef($con);
			$con = DBI->connect("DBI:mysql:database=".$mysql_database_oreon.";host=".$mysql_host, $mysql_user, $mysql_passwd, {'RaiseError' => 0, 'PrintError' => 0, 'AutoCommit' => 1});			
			if (defined($con)) {
				$flag = 1;
				writeLogFile("DataBase became UP !\n");
			}	
		}
	}
	undef($flag);
}

#
# Function : create a SSH connexion with a remote server : poller
#

sub createSSHConnexion($){
	return(-1) if (!defined($_[0]));
	my $data = getServerConfig($_[0]);
	my $ssh = Net::SSH::Perl->new($data->{'ns_ip_address'});
	print "user : ".$data->{'user'}."\n";
	print "password : ". $data->{'password'}."\n";
	$ssh->login($data->{'user'}, $data->{'password'});
	undef($data);
	return($ssh);
}

#
# Send an external command on a remote server.
# Param : id_remote_server, external command
#

sub sendExternalCommand($$){
	my $id = $_[0];
	my $cmd = $_[1];
	
	my $command_file = getNagiosConfigurationField($id, "command_file");
	my $str = "echo \"".$cmd."\" >> $command_file"; 
	my $stdout = `sudo $str`;
    print " RESULT : ".$stdout . "\n";
	undef($command_file);
}

#
# Get PerfdataFile
#

sub getNagiosInformation($){

}

sub GetPerfData($){
	my $id = $_[0];
	my $server_info = getServerConfig($id);
	#my $distantconnexion = $server_info->{'user'}."@".$server_info->{'ns_ip_address'};
	my $distantconnexion = $server_info->{'ns_ip_address'};
	
	my $distantperffile = "/usr/local/nagios/var/service-perfdata";
	my $distanttmpperffile = "/usr/local/nagios/var/service-perfdata-old";
	
	my $localtmpperffile = "/usr/local/nagios/var/service-perfdata-tmpsat".$id;
	my $localperffile = "/usr/local/nagios/var/service-perfdata";
	
	my $origin = $distantconnexion.":".$distanttmpperffile;
	
	print "ssh -q -i ~/.ssh/id_dsa $distantconnexion ls -l $distantperffile | wc -l 2>> /dev/null\n";
	my $ls = `ssh -q -i ~/.ssh/id_dsa $distantconnexion ls -l $distantperffile | wc -l 2>> /dev/null`;
	print $ls."\n";
	
	if ($ls){
		# Move perfdata file in temp dir
		print "ssh -q -i ~/.ssh/id_dsa $distantconnexion mv $distantperffile $distanttmpperffile\n";
		`ssh -q -i ~/.ssh/id_dsa $distantconnexion mv $distantperffile $distanttmpperffile`;
		# Get Perfdata file
		print "scp -q -i ~/.ssh/id_dsa $origin $localtmpperffile\n";
		`scp -q -i ~/.ssh/id_dsa $origin $localtmpperffile`;
		# Remove old perfdata file 
		print "ssh -q -i ~/.ssh/id_dsa $distantconnexion rm $distanttmpperffile\n";
		`ssh -q -i ~/.ssh/id_dsa $distantconnexion rm $distanttmpperffile`;
		
		if (-f $localtmpperffile){
			print "cat $localtmpperffile >> $localperffile\n";
			`cat $localtmpperffile >> $localperffile`;
			`rm -f $localtmpperffile`;
			#`rm -f /usr/local/nagios/var/service-perfdata.$id`;
		}
	}
}
	

sub GetLogFile($){
	my $id = $_[0];
	my $server_info = getServerConfig($id);

	my $distantconnexion = $server_info->{'ns_ip_address'};
	
	mkdir "/usr/local/centreon/var/log/nagios/$id/" if (!-d "/usr/local/centreon/var/log/nagios/$id/");
	if (-d "/usr/local/centreon/var/log/nagios/$id/"){
		
		my $distantlogfile = "/usr/local/nagios/var/nagios.log";
		my $locallogfile = "/usr/local/centreon/var/log/nagios/$id/nagios.log";
		
		my $origin = $distantconnexion.":".$distantlogfile;
		
		my $ls = `ssh -q -i ~/.ssh/id_dsa $distantconnexion ls -l $distantlogfile | wc -l 2>> /dev/null`;
		
		if ($ls){
			# Get log file
			`scp -q -i ~/.ssh/id_dsa $origin $locallogfile`;
		}
	} else {
		writeLogFile("Unable to create /usr/local/centreon/var/log/nagios/$id/. Can get nagios log file for poller $id\n");
	}
}

#
# Send config files to a remote server 
#

sub sendFile($$){
	my $filename = $_[0];
	my $destination = $_[1];
	
	return 1;
}

sub sendConfigFile($){
	my $id = $_[0];
	my $cfg_dir = getNagiosConfigurationField($_[0], "cfg_dir");
	my $server_info = getServerConfig($_[0]);
	my ($md5local, $md5dist, $scpe);
	
	opendir(DIR, $installedPath."/filesGeneration/nagiosCFG/$id/");
	while (my $file = readdir(DIR)){
		if ($file ne "." && $file ne ".." && $file !~ /\~/ && $file ne "nagiosCFG.DEBUG"){
			my $origin = $installedPath."/filesGeneration/nagiosCFG/".$id."/$file";
			my $dest = $server_info->{'user'}."@".$server_info->{'ns_ip_address'}.":$cfg_dir$file";

			my $stdout = `scp $origin $dest`;
			
			# Check sucessfull copy
			$md5local = `/usr/bin/md5sum $origin`;
			$md5dist  = `ssh $server_info->{'ns_ip_address'} /usr/bin/md5sum $cfg_dir$file`;
			
			my @tab_local = split(' ', $md5local);		
			my @tab_dist = split(' ', $md5dist);		
			if ($tab_local[0] ne $tab_dist[0]){
				print "Bad Copy !\n";
			}
		}
	}
	undef($cfg_dir);
}

sub restartNagios($){
	my $id = $_[0];
	my($stdout, $stderr, $exit);
	if ($method =~ /system/){
		my $data = getServerConfig($id);
		my $distantconnexion = $data->{'user'}."@".$data->{'ns_ip_address'};
		print "ssh $distantconnexion sudo /etc/init.d/nagios restart\n";
		$stdout = `ssh $distantconnexion sudo /etc/init.d/nagios restart`;
		undef($distantconnexion);
	} else {
		my $ssh = createSSHConnexion($_[0]);
	   	($stdout, $stderr, $exit) = $ssh->cmd("/etc/init.d/nagios restart");
	}
    print " RESULT : ".$stdout . "\n";
}

sub synchronizePlugins($){
	my $scpe = Net::SCP::Expect->new("timeout", "20");
	$scpe->login("root", "catakijy!");
	my $nagios_path_plugins = getLocalOptionsField("nagios_path_plugins");
	print "SYNCHRO : " .$nagios_path_plugins . "\n";
}

sub reloadNagios($){
	my $id = $_[0];
	my $data = getServerConfig($id);
	my $distantconnexion = $data->{'user'}."@".$data->{'ns_ip_address'};
	my $stdout = `ssh $distantconnexion sudo /etc/init.d/nagios reload`;
    print " RESULT : ".$stdout . "\n";
	undef($distantconnexion);
    undef($stdout);
	undef($data);
	undef($id);
}

sub stopNagios($){
	my $id = $_[0];
	# 
	# Just start nagios daemon
	# 
	
	# Get server configuration to create SSH connexion 
	my $data = getServerConfig($id);
	
	# Create SSH connexion string
	my $distantconnexion = $data->{'user'}."@".$data->{'ns_ip_address'};
	
	# Launch command line
	my $stdout = `ssh $distantconnexion sudo /etc/init.d/nagios stop`;
	print " RESULT : ".$stdout . "\n";
	undef($distantconnexion);
    undef($stdout);
	undef($data);
	undef($id);
}

sub startNagios($){
	my $id = $_[0];
	# 
	# Just start nagios daemon
	# 
	
	# Get server configuration to create SSH connexion 
	my $data = getServerConfig($id);
	
	# Create SSH connexion string
	my $distantconnexion = $data->{'user'}."@".$data->{'ns_ip_address'};

	# Launch command line
	my $stdout = `ssh $distantconnexion sudo /etc/init.d/nagios start`;
	print " RESULT : ".$stdout . "\n";
	undef($distantconnexion);
    undef($stdout);
	undef($data);
	undef($id);
}

sub NagioStat($){
	my $id = $_[0];
	my $data = getServerConfig($id);
	my $distantconnexion = $data->{'user'}."@".$data->{'ns_ip_address'};
	my $stdout = `ssh $distantconnexion sudo /usr/sbin/nagiostats`;
	print " RESULT : ".$stdout . "\n";
	undef($distantconnexion);
    undef($stdout);
	undef($data);
	undef($id);
}

sub CheckPerf($){

}

sub testConfig($){
	my $id = $_[0];
	my($stdout, $stderr, $exit);
	my $cfg_dir = getNagiosConfigurationField($id, "cfg_dir");
	if ($method =~ /system/){
		my $data = getServerConfig($id);
		my $distantconnexion = $data->{'user'}."@".$data->{'ns_ip_address'};
		$stdout = `ssh $distantconnexion sudo /usr/sbin/nagios -v $cfg_dir/nagios.cfg`;
		undef($distantconnexion);
	} else {
		my $ssh = createSSHConnexion($id);
	    ($stdout, $stderr, $exit) = $ssh->cmd("sudo /usr/sbin/nagios -v $cfg_dir/nagios.cfg");
    }
    print " RESULT : ".$stdout . "\n";
    undef($cfg_dir);
}

sub parseRequest($){
	return if (!$_[0]);
	if ($_[0] =~ /RESTART\:([0-9]*)/){
		restartNagios($1);
	} elsif ($_[0] =~ /RELOAD\:([0-9]*)/){
		reloadNagios($1);
	} elsif ($_[0] =~ /START\:([0-9]*)/){
		startNagios($1);
	} elsif ($_[0] =~ /SENDCFGFILE\:([0-9]*)/){
		sendConfigFile($1);
	} elsif ($_[0] =~ /STOP\:([0-9]*)/){
		stopNagios($1);
	} elsif ($_[0] =~ /PERF\:([0-9]*)/){
		CheckPerf($1);
	} elsif ($_[0] =~ /NAGIOSTAT\:([0-9]*)/){
		NagioStat($1);
	} elsif ($_[0] =~ /TEST\:([0-9]*)/){
		testConfig($1);
	} elsif ($_[0] =~ /EXTERNALCMD\:([0-9]*)\:([.]*)/){
		sendExternalCommand($1, $2);
	} elsif ($_[0] =~ /SYNCHRONIZEPLUGINS\:([0-9]*)\:([.]*)/){
		synchronizePlugins($1);
	} else {
		writeLogFile("$_[0] : UNKNWON KEY \n");
	}
}

unlink($PID);
writeLogFile("Centcore stop...\n");
exit();

__END__




