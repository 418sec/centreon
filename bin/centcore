#! /usr/bin/perl -w
###################################################################
# Centreon is developped with GPL Licence 2.0 
#
# GPL License: http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
#
# Developped by : Julien Mathis - Romain Le Merlus
#
###################################################################
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
#    For information : contact@merethis.com
####################################################################
#
# Script init
#

use strict;
use POSIX qw(mkfifo);
use DBI;
use Net::SSH::Perl;
use Net::SCP;
use Net::SCP::Expect;

use vars qw($debug $LOG %status $generalcounter $stop $method);
use vars qw($mysql_user $mysql_passwd $mysql_host $mysql_database_oreon $mysql_database_ods);
use vars qw($con);


$method = "system";

$debug = 0;
my $installedPath = "/srv/oreon/";
$LOG = $installedPath."var/centcore.log";
my $PID = $installedPath."var/centcore.pid";
my $FIFO = $installedPath."var/centcore";
$stop = 1;

# Include Configuration Data
require $installedPath."etc/conf.pm";

sub catch_zap {
	$stop = 0;
	writeLogFile("Receiving order to stop...\n");
}

sub writeLogFile($){
	open (LOG, ">> ".$LOG) || print "can't write $LOG: $!";
	print LOG time()." - ".$_[0];
	close LOG or warn $!;
}

# Starting ODS Engine
writeLogFile("Starting ODS engine...\n");
writeLogFile("PID : ".$$."\n");

# checking if pid file exists.
if (-x $PID){
	writeLogFile("centcore already running. can't launch again....\n");
	exit(2);
}

# Writing PID
open (PID, ">> ".$PID) || print "can't write PID : $!";
print PID $$ ;
close PID or warn $!;

# Set signals
$SIG{INT}  		= \&catch_zap;
$SIG{'CHLD'} 	= 'IGNORE' ;

# Functions

sub getNagiosConfigurationField($$){
	CheckMySQLConnexion();
	my $sth2 = $con->prepare("SELECT ".$_[1]." FROM `cfg_nagios` WHERE `nagios_server_id` = '".$_[0]."'");
	writeLogFile("Error when getting server properties : ".$sth2->errstr."\n") if (!$sth2->execute());
	my $data = $sth2->fetchrow_hashref();
	return $data->{$_[1]};
}

sub getLocalOptionsField($){
	CheckMySQLConnexion();
	my $sth2 = $con->prepare("SELECT ".$_[0]." FROM `general_opt` LIMIT 1");
	writeLogFile("Error when getting general options properties : ".$sth2->errstr."\n") if (!$sth2->execute());
	my $data = $sth2->fetchrow_hashref();
	return $data->{$_[0]};
}

sub getServerConfig($){
	CheckMySQLConnexion();
	my $sth2 = $con->prepare("SELECT * FROM `nagios_server` WHERE `id` = '".$_[0]."'");
	writeLogFile("Error when getting server properties : ".$sth2->errstr."\n") if (!$sth2->execute());
	return $sth2->fetchrow_hashref();
}

sub CheckMySQLConnexion(){
	my $flag = 0;
	while (!defined($con) || !$con->ping){
		if (!defined($con)) {
			$con = DBI->connect("DBI:mysql:database=".$mysql_database_oreon.";host=".$mysql_host, $mysql_user, $mysql_passwd, {'RaiseError' => 0, 'PrintError' => 0, 'AutoCommit' => 1});
			if (!defined($con)) {
				writeLogFile("Error when connecting to database : ".$DBI::errstr."\n");
				sleep(2);
			}
		} else {
			sleep(2);
			undef($con);
			$con = DBI->connect("DBI:mysql:database=".$mysql_database_oreon.";host=".$mysql_host, $mysql_user, $mysql_passwd, {'RaiseError' => 0, 'PrintError' => 0, 'AutoCommit' => 1});			
			if (defined($con)) {
				$flag = 1;
				writeLogFile("DataBase became UP !\n");
			}	
		}
	}
	undef($flag);
}

#
# Function : create a SSH connexion with a remote server : poller
#

sub createSSHConnexion($){
	return(-1) if (!defined($_[0]));
	my $data = getServerConfig($_[0]);
	my $ssh = Net::SSH::Perl->new($data->{'ns_ip_address'});
	print "user : ".$data->{'user'}."\n";
	print "password : ". $data->{'password'}."\n";
	$ssh->login($data->{'user'}, $data->{'password'});
	undef($data);
	return($ssh);
}

#
# Send an external command on a remote server.
# Param : id_remote_server, external command
#

sub sendExternalCommand($$){
	my $id = $_[0];
	my $cmd = $_[1];
	
	my $command_file = getNagiosConfigurationField($id, "command_file");
	my($stdout, $stderr, $exit);
	if ($method =~ /system/){
		my $str = "echo \"".$cmd."\" >> $command_file"; 
		$stdout = `sudo $str`;
	} else {
		my $ssh = createSSHConnexion($id);
    	($stdout, $stderr, $exit) = $ssh->cmd("echo \"".$cmd."\" >> $command_file");
    }
    print " RESULT : ".$stdout . "\n";
	undef($command_file);
}

#
# Send config files to a remote server 
#

sub sendConfigFile($){
	my $id = $_[0];
	my $cfg_dir = getNagiosConfigurationField($_[0], "cfg_dir");
	my $server_info = getServerConfig($_[0]);
	my ($md5local, $md5dist, $scpe);
	if ($method !~ /system/){
		my $scpe = Net::SCP::Expect->new("timeout", "20");
		$scpe->login("root", "catakijy!");
	}
    opendir(DIR, $installedPath."/filesGeneration/nagiosCFG/$id/");
	while (my $file = readdir(DIR)){
		if ($file ne "." && $file ne ".." && $file !~ /\~/ && $file ne "nagiosCFG.DEBUG"){
							
			my $origin = $installedPath."/filesGeneration/nagiosCFG/".$id."/$file";
			my $dest = $server_info->{'ns_ip_address'}.":$cfg_dir$file";

			if ($method =~ /system/){
				my $stdout = `scp $origin $dest`;
			} else {
				# Send File With User and Login
				$scpe->scp($origin, $dest);			
			}
			
			# Check sucessfull copy
			$md5local = `/usr/bin/md5sum $origin`;
			$md5dist  = `ssh $server_info->{'ns_ip_address'} /usr/bin/md5sum $cfg_dir$file`;
			
			my @tab_local = split(' ', $md5local);		
			my @tab_dist = split(' ', $md5dist);		
			if ($tab_local[0] ne $tab_dist[0]){
				print "Bad Copy !\n";
			}
		}
	}
	undef($cfg_dir);
}

sub restartNagios($){
	my $id = $_[0];
	my($stdout, $stderr, $exit);
	if ($method =~ /system/){
		my $data = getServerConfig($id);
		$stdout = `ssh $data->{'ns_ip_address'} sudo /etc/init.d/nagios restart`;
	} else {
		my $ssh = createSSHConnexion($_[0]);
	   	($stdout, $stderr, $exit) = $ssh->cmd("/etc/init.d/nagios restart");
	}
    print " RESULT : ".$stdout . "\n";
}

sub synchronizePlugins($){
	my $scpe = Net::SCP::Expect->new("timeout", "20");
	$scpe->login("root", "catakijy!");
	my $nagios_path_plugins = getLocalOptionsField("nagios_path_plugins");
	print "SYNCHRO : " .$nagios_path_plugins . "\n";
}

sub reloadNagios($){
	my $id = $_[0];
	my($stdout, $stderr, $exit);
	if ($method =~ /system/){
		my $data = getServerConfig($id);
		$stdout = `ssh $data->{'ns_ip_address'} sudo /etc/init.d/nagios reload`;
	} else {
		my $ssh = createSSHConnexion($_[0]);
	    ($stdout, $stderr, $exit) = $ssh->cmd("sudo /etc/init.d/nagios reload");
	}
    print " RESULT : ".$stdout . "\n";
}

sub stopNagios($){
	my $id = $_[0];
	my($stdout, $stderr, $exit);
	if ($method =~ /system/){
		my $data = getServerConfig($id);
		$stdout = `ssh $data->{'ns_ip_address'} sudo /etc/init.d/nagios stop`;
	} else {
		my $ssh = createSSHConnexion($_[0]);
    	($stdout, $stderr, $exit) = $ssh->cmd("sudo /etc/init.d/nagios stop");
    }
    print " RESULT : ".$stdout . "\n";
}

sub startNagios($){
	my $id = $_[0];
	my($stdout, $stderr, $exit);
	if ($method =~ /system/){
		my $data = getServerConfig($id);
		$stdout = `ssh $data->{'ns_ip_address'} sudo /etc/init.d/nagios start`;
	} else {
		my $ssh = createSSHConnexion($_[0]);
	    ($stdout, $stderr, $exit) = $ssh->cmd("sudo /etc/init.d/nagios start");
    }
    print " RESULT : ".$stdout . "\n";
}

sub NagioStat($){
	my $id = $_[0];
	my($stdout, $stderr, $exit);
	if ($method =~ /system/){
		my $data = getServerConfig($id);
		$stdout = `ssh $data->{'ns_ip_address'} sudo /usr/sbin/nagiostats`;
	} else {
		my $ssh = createSSHConnexion($_[0]);
	    ($stdout, $stderr, $exit) = $ssh->cmd("sudo /usr/sbin/nagiostats");
	}
    print " RESULT : ".$stdout . "\n";
}

sub CheckPerf($){
	print "";
}

sub testConfig($){
	my $id = $_[0];
	my($stdout, $stderr, $exit);
	my $cfg_dir = getNagiosConfigurationField($id, "cfg_dir");
	if ($method =~ /system/){
		my $data = getServerConfig($id);
		$stdout = `ssh $data->{'ns_ip_address'} sudo /usr/sbin/nagios -v $cfg_dir/nagios.cfg`;
	} else {
		my $ssh = createSSHConnexion($id);
	    ($stdout, $stderr, $exit) = $ssh->cmd("sudo /usr/sbin/nagios -v $cfg_dir/nagios.cfg");
    }
    print " RESULT : ".$stdout . "\n";
    undef($cfg_dir);
}


sub parseRequest($){
	return if (!$_[0]);
	if ($_[0] =~ /RESTART\:([0-9]*)/){
		restartNagios($1);
	} elsif ($_[0] =~ /RELOAD\:([0-9]*)/){
		reloadNagios($1);
	} elsif ($_[0] =~ /START\:([0-9]*)/){
		startNagios($1);
	} elsif ($_[0] =~ /SENDCFGFILE\:([0-9]*)/){
		sendConfigFile($1);
	} elsif ($_[0] =~ /STOP\:([0-9]*)/){
		stopNagios($1);
	} elsif ($_[0] =~ /PERF\:([0-9]*)/){
		CheckPerf($1);
	} elsif ($_[0] =~ /NAGIOSTAT\:([0-9]*)/){
		NagioStat($1);
	} elsif ($_[0] =~ /TEST\:([0-9]*)/){
		testConfig($1);
	} elsif ($_[0] =~ /EXTERNALCMD\:([0-9]*)\:([.]*)/){
		sendExternalCommand($1, $2);
	} elsif ($_[0] =~ /SYNCHRONIZEPLUGINS\:([0-9]*)\:([.]*)/){
		synchronizePlugins($1);
	}
}

unless (-p $FIFO) {
    unlink $FIFO;
    POSIX::mkfifo($FIFO, 0755) or die "can't mkfifo $FIFO: $!";
}

unlink $FIFO if (-p $FIFO);

unless (-p $FIFO) {
    unlink $FIFO;
    require POSIX;
    POSIX::mkfifo($FIFO, 0755) or die "can't mkfifo $FIFO: $!";
}

while (1) {
    open (FIFO, "< $FIFO") or die("");
    while (<FIFO>){
        parseRequest($_);
    }
}
close FIFO;
unlink($PID);

exit();
